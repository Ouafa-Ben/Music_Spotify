# CREATE DATABASE AND USE IT
CREATE DATABASE music; 
USE music;
------------------
# CREATE 5 TABELS
# TRACK TABLE
CREATE TABLE TRACK
(
TRACK_ID VARCHAR(5) NOT NULL UNIQUE,
ALBUM_ID VARCHAR(10) NOT NULL,
TRACK_NAME VARCHAR(200) NOT NULL, 
RELEASE_DATE DATE, 
LENGTH TIME NOT NULL,
PRIMARY KEY(TRACK_ID)
); 
---------------
# ARTIST TABLE
CREATE TABLE ARTIST
(
ARTIST_ID  VARCHAR(10) NOT NULL UNIQUE,
ARTIST_NAME VARCHAR(50) NOT NULL,
PRIMARY KEY(ARTIST_ID)
);
---------------
# ALBUM TABLE
CREATE TABLE ALBUM 
(
ALBUM_ID  VARCHAR(10) NOT NULL UNIQUE, 
ARTIST_ID VARCHAR(10) NOT NULL,
ALBUM_NAME VARCHAR(100) NOT NULL,
PRIMARY KEY(ALBUM_ID)
);
-------------------
# REVIEW TABLE
CREATE TABLE REVIEW
(
REVIEW_ID VARCHAR(10) NOT NULL,
TRACK_ID VARCHAR(5) NOT NULL,
POPULARITY INT NOT NULL,
PRIMARY KEY(REVIEW_ID)
); 
------------------
# TRACK PROPERTIES TABLE
CREATE TABLE TRACK_PROPERTIES
(
TRACK_ID VARCHAR(5) NOT NULL UNIQUE, 
ACOUSTICNESS FLOAT NOT NULL, 
DANCEABILITY FLOAT NOT NULL, 
ENERGY FLOAT NOT NULL, 
INSTRUMENTALNESS FLOAT NOT NULL, 
LIVENESS FLOAT NOT NULL, 
LOUDNESS DECIMAL NOT NULL, 
SPEACHINESS FLOAT NOT NULL, 
TEMPO DECIMAL NOT NULL, 
TIME_SIGNATURE INT NOT NULL
); 
------------------
# Check all tabels
SELECT *
FROM MUSIC.TRACK;

SELECT *
FROM MUSIC.ALBUM;

SELECT *
FROM MUSIC.ARTIST;

SELECT *
FROM MUSIC.REVIEW;

SELECT *
FROM MUSIC.TRACK_PROPERTIES;
------------------ 
# I noticed track_id in track_properties table is set as primary key it's because I set it unique by mistake. I have to drop it first before I change it to foreign key

ALTER TABLE TRACK_PROPERTIES
DROP INDEX TRACK_ID;

#I CHANGED THE SETTING HERE AS I WAS GETTING ERROR 1452 CANNOT ADD OR UPDATE A CHILD ROW A FOREIGN KEY CONTRAINS FAILS AND THIS WAS THE ONLY WAY TO FIX IT
SET FOREIGN_KEY_CHECKS=0;
------------------
# Add foreign key

ALTER TABLE ALBUM
ADD FOREIGN KEY(ARTIST_ID) REFERENCES ARTIST(ARTIST_ID);

ALTER TABLE TRACK
ADD FOREIGN KEY (ALBUM_ID) REFERENCES ALBUM(ALBUM_ID); 

ALTER TABLE REVIEW 
ADD FOREIGN KEY (TRACK_ID) REFERENCES TRACK(TRACK_ID); 

ALTER TABLE TRACK_PROPERTIES 
ADD FOREIGN KEY(TRACK_ID) REFERENCES TRACK(TRACK_ID);
------------------
# Check all tabels
SELECT *
FROM MUSIC.TRACK;

SELECT *
FROM MUSIC.ALBUM;

SELECT *
FROM MUSIC.ARTIST;

SELECT *
FROM MUSIC.REVIEW;

SELECT *
FROM MUSIC.TRACK_PROPERTIES;
------------------
# Make sure my id values are all unique USING TWO DIFFRENT APPROACHES
# DISTICT AND GROUP BY
# GROUP BY AND HAVING

SELECT DISTINCT TRACK_ID,
COUNT(DISTINCT TRACK_ID) AS TRACK_NUM
FROM MUSIC.TRACK
GROUP BY TRACK_ID;

SELECT ALBUM_ID,
COUNT(ALBUM_ID) AS TOTAL_NUMBER
FROM MUSIC.ALBUM
GROUP BY ALBUM_ID
HAVING COUNT(ALBUM_ID)> 1;

SELECT DISTINCT ALBUM_ID,
COUNT(DISTINCT ALBUM_ID)
FROM MUSIC.TRACK
GROUP BY ALBUM_ID;

SELECT DISTINCT ARTIST_ID,
COUNT(DISTINCT ARTIST_ID)
FROM MUSIC.ALBUM
GROUP BY ARTIST_ID;

SELECT DISTINCT ARTIST_ID,
COUNT(DISTINCT ARTIST_ID)
FROM MUSIC.ARTIST
GROUP BY ARTIST_ID;

SELECT REVIEW_ID,
COUNT(REVIEW_ID) AS TOTAL_NUM
FROM MUSIC.REVIEW
GROUP BY REVIEW_ID
HAVING COUNT(REVIEW_ID)>1;

SELECT DISTINCT TRACK_ID,
COUNT(DISTINCT TRACK_ID)
FROM MUSIC.REVIEW
GROUP BY TRACK_ID;

SELECT TRACK_ID,
COUNT(TRACK_ID)
FROM MUSIC.TRACK_PROPERTIES
GROUP BY TRACK_ID
HAVING COUNT(TRACK_ID)>1;
------------------
# LEFT JOIN UNION RIGHT JOIN using track and review table
SELECT TRACK.TRACK_NAME, 
REVIEW.POPULARITY
FROM MUSIC.TRACK
LEFT JOIN MUSIC.REVIEW
ON TRACK.TRACK_ID = REVIEW.TRACK_ID
UNION
SELECT TRACK.TRACK_NAME, 
REVIEW.POPULARITY
FROM MUSIC.TRACK
RIGHT JOIN MUSIC.REVIEW
ON TRACK.TRACK_ID = REVIEW.TRACK_ID
GROUP BY TRACK_NAME
ORDER BY TRACK_NAME; 
------------------
# FIND AVG MIN MAX POPULARITY 
SELECT COUNT(REVIEW_ID) AS NUM_OF_SONGS,
AVG(POPULARITY) AS POPULARITY_MEAN, 
MIN(POPULARITY) AS MIN, 
MAX(POPULARITY) AS MAX
FROM MUSIC.REVIEW;
------------------
# Find AVG MIN MAX track length
SELECT COUNT(TRACK_ID) AS NUM_OF_SONGS,
SEC_TO_TIME(AVG(TIME_TO_SEC(`LENGTH`))) AS AVG_LENGTH,
MIN(LENGTH) AS MIN_LENGTH, 
MAX(LENGTH) AS MAX_LENGTH
FROM MUSIC.TRACK;
------------------
#TRACK RELEASE BY YEAR 

SELECT COUNT(TRACK_ID) AS NUM_SONG_YEAR,
YEAR(RELEASE_DATE) YEAR
FROM MUSIC.TRACK
GROUP BY YEAR
ORDER BY YEAR;
------------------
#TRACK RELEASE BY MONTH 

SELECT COUNT(TRACK_ID) AS NUM_SONG_MONTH,
MONTH(RELEASE_DATE) MONTH
FROM MUSIC.TRACK
GROUP BY MONTH
ORDER BY MONTH;
------------------
#TRACK RELEASE BY DAY 

SELECT COUNT(TRACK_ID) AS NUM_SONG_DAY,
DAY(RELEASE_DATE) DAY
FROM MUSIC.TRACK
GROUP BY DAY
ORDER BY DAY;
------------------
# CREATE STORED FUNCTION TO RATE TRACKS BASED ON THEIR POPULARITY

DELIMITER $$
CREATE FUNCTION RAITING(POPULARITY INT)
RETURNS VARCHAR(10)
DETERMINISTIC
BEGIN
DECLARE RAITING VARCHAR(10);
IF POPULARITY < 25 THEN
SET RAITING = "Meh..";
ELSEIF (POPULARITY >= 25 AND POPULARITY <= 50) THEN 
SET RAITING = "GOOD";
ELSEIF POPULARITY > 50 THEN
SET RAITING ="Love it!!";
END IF;
RETURN (RAITING);

END $$

DELIMITER ;

# Test my stored function 
SELECT TRACK_NAME, 
RAITING(POPULARITY) AS RAITING
FROM MUSIC.TRACK, MUSIC.REVIEW
WHERE TRACK.TRACK_ID = REVIEW.TRACK_ID
ORDER BY TRACK_NAME ASC;
------------------
# Create trigger
# First I need to create the table where I will save the resulted values from my trigger 

CREATE TABLE ARTIST_CHANGES (
    id INT AUTO_INCREMENT PRIMARY KEY,
    ARTIST_ID VARCHAR(10) NOT NULL,
    ARTIST_NAME VARCHAR(50) NOT NULL,
    CHANGE_DATE DATETIME NOT NULL,
    ACTION VARCHAR(50) NOT NULL
);

# CREATE TRIGGER
CREATE TRIGGER BEFORE_ARTIST_INSERT
    BEFORE INSERT ON ARTIST
    FOR EACH ROW 
 INSERT INTO ARTIST_CHANGES
 SET ACTION = 'INSERT',
     ARTIST_ID = NEW.ARTIST_ID,
     ARTIST_NAME = NEW.ARTIST_NAME,
     CHANGE_DATE = NOW();
     
# Test my trigger 
INSERT INTO ARTIST
(ARTIST_ID, ARTIST_NAME)
VALUES 
("A8", "RIHANNA");

# Check trigger table for confirmation
SELECT * FROM music.artist_changes;

# To delete later on the extra artist name I added
DELETE FROM ARTIST
WHERE ARTIST_ID ="A8";
------------------
# CREATE VIEW with FOUR tables 

CREATE VIEW TRACK_ALBUM_ARTIST_POPULARITY AS
SELECT ALBUM.ALBUM_NAME,
TRACK.TRACK_NAME, 
ARTIST.ARTIST_NAME,
REVIEW.POPULARITY
FROM MUSIC.TRACK, MUSIC.ALBUM, MUSIC.ARTIST, MUSIC.REVIEW
WHERE TRACK.TRACK_ID = REVIEW.TRACK_ID AND
TRACK.ALBUM_ID = ALBUM.ALBUM_ID AND
ALBUM.ARTIST_ID = ARTIST.ARTIST_ID
ORDER BY REVIEW.POPULARITY DESC;

SELECT * FROM music.track_album_artist_popularity;

# SUBQUERY using my view table 

SELECT ALBUM_NAME, 
TRACK_NAME, 
ARTIST_NAME,
POPULARITY
FROM music.track_album_artist_popularity
WHERE POPULARITY IN (SELECT POPULARITY 
						FROM music.track_album_artist_popularity 
                        WHERE POPULARITY BETWEEN 50 AND 100);
------------------
# Find top 10 popular tracks and properties

SELECT TRACK_NAME, 
POPULARITY, 
ACOUSTICNESS, 
DANCEABILITY, 
ENERGY, 
INSTRUMENTALNESS, 
LIVENESS, 
LOUDNESS, 
SPEACHINESS, 
TEMPO, 
TIME_SIGNATURE
FROM MUSIC.TRACK_PROPERTIES, MUSIC.REVIEW, MUSIC.TRACK
WHERE TRACK.TRACK_ID = TRACK_PROPERTIES.TRACK_ID AND 
TRACK.TRACK_ID = REVIEW.TRACK_ID
ORDER BY POPULARITY DESC
LIMIT 10;
------------------

